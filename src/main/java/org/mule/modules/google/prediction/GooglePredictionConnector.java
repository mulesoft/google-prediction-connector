/**
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 **/

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.google.prediction;

import java.io.IOException;

import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.oauth.OAuth2;
import org.mule.api.annotations.oauth.OAuthAccessToken;
import org.mule.api.annotations.oauth.OAuthAccessTokenIdentifier;
import org.mule.api.annotations.oauth.OAuthAuthorizationParameter;
import org.mule.api.annotations.oauth.OAuthConsumerKey;
import org.mule.api.annotations.oauth.OAuthConsumerSecret;
import org.mule.api.annotations.oauth.OAuthInvalidateAccessTokenOn;
import org.mule.api.annotations.oauth.OAuthPostAuthorization;
import org.mule.api.annotations.oauth.OAuthProtected;
import org.mule.api.annotations.oauth.OAuthScope;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.modules.google.AbstractGoogleOAuthConnector;
import org.mule.modules.google.AccessType;
import org.mule.modules.google.ForcePrompt;
import org.mule.modules.google.IdentifierPolicy;
import org.mule.modules.google.oauth.invalidation.InvalidationAwareCredential;
import org.mule.modules.google.oauth.invalidation.OAuthTokenExpiredException;
import org.mule.modules.google.prediction.model.Analyze;
import org.mule.modules.google.prediction.model.List;
import org.mule.modules.google.prediction.model.Output;
import org.mule.modules.google.prediction.model.Training;

import com.google.api.client.auth.oauth2.BearerToken;
import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.jackson.JacksonFactory;
import com.google.api.services.prediction.Prediction;
import com.google.api.services.prediction.PredictionScopes;
import com.google.api.services.prediction.model.Input;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Connector(name="google-prediction", schemaVersion="1.0", friendlyName="Google Prediction", minMuleVersion="3.4", configElementName="config-with-oauth")
@OAuth2(
        authorizationUrl = "https://accounts.google.com/o/oauth2/auth",
        accessTokenUrl = "https://accounts.google.com/o/oauth2/token",
		accessTokenRegex="\"access_token\"[ ]*:[ ]*\"([^\\\"]*)\"",
		expirationRegex="\"expires_in\"[ ]*:[ ]*([\\d]*)",
		refreshTokenRegex="\"refresh_token\"[ ]*:[ ]*\"([^\\\"]*)\"",
		authorizationParameters={
				@OAuthAuthorizationParameter(name="access_type", defaultValue="online", type=AccessType.class, description="Indicates if your application needs to access a Google API when the user is not present at the browser. " + 
											" Use offline to get a refresh token and use that when the user is not at the browser. Default is online", optional=true),
				@OAuthAuthorizationParameter(name="force_prompt", defaultValue="auto", type=ForcePrompt.class, description="Indicates if google should remember that an app has been authorized or if each should ask authorization every time. " + 
											" Use force to request authorization every time or auto to only do it the first time. Default is auto", optional=true)
        }
)
public class GooglePredictionConnector extends AbstractGoogleOAuthConnector {

    /**
     * The OAuth2 consumer key
     */
    @Configurable
    @OAuthConsumerKey
    private String consumerKey;

    /**
     * The OAuth2 consumer secret
     */
    @Configurable
    @OAuthConsumerSecret
    private String consumerSecret;

    /**
     * The OAuth scopes you want to request
     */
    @OAuthScope
    @Configurable
    @Optional
    @Default(USER_PROFILE_SCOPE + " " + PredictionScopes.PREDICTION)
    private String scope;
    
    /**
     * This policy represents which id we want to use to represent each google account.
     * 
     * PROFILE means that we want the google profile id. That means, the user's primary key in google's DB.
     * This is a long number represented as a string.
     * 
     * EMAIL means you want to use the account's email address
     */
    @Configurable
    @Optional
    @Default("EMAIL")
    private IdentifierPolicy identifierPolicy = IdentifierPolicy.EMAIL;

    /**
     * Application name registered on Google API console
     */
    @Configurable
    @Optional
    @Default("Mule-GooglePredictionConnector/1.0")
    private String applicationName;

    @OAuthAccessToken
    private String accessToken;

    /**
     * The google api client
     */
    private Prediction client;
    
    @OAuthAccessTokenIdentifier
	public String getAccessTokenId() {
		return this.identifierPolicy.getId(this);
	}
	
	@OAuthPostAuthorization
	public void postAuth() {
		Credential credential = new InvalidationAwareCredential(BearerToken.authorizationHeaderAccessMethod());
		credential.setAccessToken(this.getAccessToken());
		
		this.client = new Prediction.Builder(new NetHttpTransport(), new JacksonFactory(), credential)
					    	.setApplicationName(this.applicationName)
					    	.build();
	}

    public String getConsumerKey() {
        return consumerKey;
    }

    /**
     * Set property
     *
     * @param consumerKey Consumer Key
     */
    public void setConsumerKey(String consumerKey) {
        this.consumerKey = consumerKey;
    }

    public String getConsumerSecret() {
        return consumerSecret;
    }

    /**
     * Set property
     *
     * @param consumerSecret Consumer Secret
     */
    public void setConsumerSecret(String consumerSecret) {
        this.consumerSecret = consumerSecret;
    }

    public String getApplicationName() {
        return applicationName;
    }

    /**
     * Set property
     *
     * @param applicationName Application Name
     */
    public void setApplicationName(String applicationName) {
        this.applicationName = applicationName;
    }

    /**
     * Set property
     *
     * @param scope Oauth Scope Identifier
     */
    public void setScope(String scope) {
        this.scope = scope;
    }

    public String getScope() {
        return scope;
    }


    /**
     * Inserts a new calendar associated with the user that owns the current OAuth token
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:list}
     *

     * @return another instance of {@link List<Training></>} representing the calendar
     *         that was created
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public java.util.List<Training> list() throws IOException {
        return new List(this.client.trainedmodels().list().execute()).getItems();
    }


    /**
     * Inserts a new calendar associated with the user that owns the current OAuth token
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:predict}
     *
     * @param modelId The name of your prediction model.
     * @param list A list containing the query strings that you want to predict.
     * @return another instance of {@link Output</>} representing the calendar
     *         that was created
     *
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Output predict(String modelId, java.util.List<Object> list) throws IOException {
        Input.InputInput inputInput = new Input.InputInput();
        inputInput.setCsvInstance(list);
        Input input = new Input();
        input.setInput(inputInput);
        return new Output(this.client.trainedmodels().predict(modelId, input).execute());
    }

    /**
     * Inserts a new calendar associated with the user that owns the current OAuth token
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:create}
     *
     * @param modelId                  the id of your prediction model.
     * @param googleStorageLocation    the id of your google storage that holds the model.
     * @param storagePMMLLocation      the id of your google storage Location that holds the PMML model.
     * @param storagePMMLModelLocation the id of your google storage Location that holds the PMML model.
     * @return another instance of {@link Training</>} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Training create(String modelId,
                                          @Optional String googleStorageLocation,
                                          @Optional String storagePMMLLocation,
                                          @Optional String storagePMMLModelLocation) throws IOException {
        com.google.api.services.prediction.model.Training training = new com.google.api.services.prediction.model.Training();

        //training.setCreated(new DateTime(new Date()));
        training.setId(modelId);
        training.setKind("prediction#training");
        if (googleStorageLocation != null) {
            training.setStorageDataLocation(googleStorageLocation);
        }
        if (storagePMMLLocation != null && storagePMMLModelLocation != null) {
            training.setStoragePMMLLocation(storagePMMLLocation);
            training.setStoragePMMLModelLocation(storagePMMLModelLocation);
        }


        return new Training(this.client.trainedmodels().insert(training).execute());
    }

    /**
     * Checks if the training of a model is completed or not.
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:training-complete}
     *
     * @param modelId     the id of your prediction model.
     * @return another instance of {@link Boolean} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Boolean trainingComplete(String modelId) throws IOException {
        return this.client.trainedmodels().get(modelId).execute().getTrainingStatus().equalsIgnoreCase("DONE");
    }


    /**
     * Deletes a prediction model using the id of that model.
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:delete}
     *
     * @param modelId the id of your prediction model.
     * @return another instance of {@link Boolean} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public void delete(String modelId) throws IOException {
        this.client.trainedmodels().delete(modelId).execute();
    }


    /**
     * Updates an existing prediction model with new data.
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:update}
     *
     * @param modelId the id of your prediction model.
     * @param label The label that you want to add more training data to.
     * @param csv A list of CSV strings that you want to update this training model with for one particular label.
     * @return another instance of {@link Prediction.Trainedmodels.Update} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers

     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Training update(String modelId, String label, java.util.List<Object> csv) throws IOException {

        return new Training(this.client.trainedmodels().update(modelId, new com.google.api.services.prediction.model.Update().setCsvInstance(csv).setLabel(label)).execute());
    }


    /**
     * Updates an existing prediction model with new data.
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:analyze}
     *
     * @param modelId the id of your prediction model.
     * @return another instance of {@link Prediction.Trainedmodels.Update} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers

     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Analyze analyze(String modelId) throws IOException {

        return new Analyze(this.client.trainedmodels().analyze(modelId).execute());
    }

    /**
     * Updates an existing prediction model with new data.
     * <p/>
     * {@sample.xml ../../../doc/GooglePrediction-connector.xml.sample google-prediction:analyze}
     *
     * @param modelId the id of your prediction model.
     * @return another instance of {@link Prediction.Trainedmodels.Update} representing the model
     *         that was created
     * @throws IOException if there's a communication error with google's servers
     */
    @Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
    public Training get(String modelId) throws IOException {
        return new Training(this.client.trainedmodels().get(modelId).execute());
    }

    @Override
    public String getAccessToken() {
        return accessToken;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public void setClient(Prediction prediction){
        this.client = prediction;
    }

	public IdentifierPolicy getIdentifierPolicy() {
		return identifierPolicy;
	}

	public void setIdentifierPolicy(IdentifierPolicy identifierPolicy) {
		this.identifierPolicy = identifierPolicy;
	}
    
}
